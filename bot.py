import os
import json
import hmac
import hashlib
import requests
from datetime import datetime
from aiohttp import web
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes

# === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ===
EXPRESS_PAY_TOKEN = os.getenv("EXPRESS_PAY_TOKEN")
EXPRESS_PAY_SECRET_WORD = os.getenv("EXPRESS_PAY_SECRET_WORD", "")
BOT_TOKEN = os.getenv("BOT_TOKEN")
APP_URL = os.getenv("APP_URL")
ADMIN_CHAT_ID = os.getenv("ADMIN_CHAT_ID")  # —Ç–≤–æ–π Telegram ID –¥–ª—è —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π
API_URL = "https://api.express-pay.by/v1/invoices"
ACCOUNT_FILE = "account_no.txt"

# === –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é ===
def main_menu():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("üí∞ –í—ã—Å—Ç–∞–≤–∏—Ç—å —Å—á—ë—Ç", callback_data="create_invoice")],
        [InlineKeyboardButton("üìä –°—Ç–∞—Ç—É—Å —Å—á—ë—Ç–∞", callback_data="check_status")]
    ])


# === –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ AccountNo ===
def get_next_account_no():
    today = datetime.now().strftime("%d%m%y")
    if os.path.exists(ACCOUNT_FILE):
        with open(ACCOUNT_FILE, "r") as f:
            data = f.read().strip()
    else:
        data = ""

    if not data.startswith(today):
        next_no = 1
    else:
        last_no = int(data[6:])
        next_no = last_no + 1

    new_account_no = f"{today}{next_no:03d}"
    with open(ACCOUNT_FILE, "w") as f:
        f.write(new_account_no)
    return new_account_no


# === Telegram –∫–æ–º–∞–Ω–¥—ã ===
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu())


async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    if query.data == "main_menu":
        await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu())
    elif query.data == "create_invoice":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É —Å—á—ë—Ç–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 25,50):")
        context.user_data["action"] = "create_invoice"
    elif query.data == "check_status":
        await query.message.reply_text("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä —Å—á—ë—Ç–∞:")
        context.user_data["action"] = "check_status"


def get_invoice_details(invoice_no: int):
    url = f"{API_URL}/{invoice_no}?token={EXPRESS_PAY_TOKEN}"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    return None


def get_invoice_list(token: str, account_no: str):
    params = {"Token": token, "AccountNo": account_no}
    response = requests.get(API_URL, params=params)
    try:
        return response.json()
    except:
        return {"Error": {"Msg": "–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –æ—Ç–≤–µ—Ç –æ—Ç ExpressPay"}}


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    action = context.user_data.get("action")

    if action == "create_invoice":
        amount = update.message.text.strip().replace(",", ".")
        account_no = get_next_account_no()

        data = {
            "Token": EXPRESS_PAY_TOKEN,
            "AccountNo": account_no,
            "Amount": amount,
            "Currency": 933,
            "Info": "–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è –¥–æ—Å—Ç–∞–≤–∫–∏"
        }

        response = requests.post(f"{API_URL}?token={EXPRESS_PAY_TOKEN}", data=data)
        if response.status_code == 200:
            invoice_no = response.json().get("InvoiceNo")
            details = get_invoice_details(invoice_no)
            if details:
                amount_info = details.get("Amount")
                account_info = details.get("AccountNo")
                account_display = f"35077-1-{account_info}"

                await update.message.reply_text(
                    f"‚úÖ –°—á—ë—Ç –Ω–∞ {amount_info} —Ä—É–±–ª–µ–π –≤—ã—Å—Ç–∞–≤–ª–µ–Ω.\n"
                    f"–ù–æ–º–µ—Ä —Å—á—ë—Ç–∞: `{account_display}`",
                    parse_mode="Markdown",
                    reply_markup=main_menu()
                )
            else:
                await update.message.reply_text(
                    f"‚úÖ –°—á—ë—Ç –≤—ã—Å—Ç–∞–≤–ª–µ–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏.\n"
                    f"InvoiceNo: {invoice_no}",
                    reply_markup=main_menu()
                )
        else:
            await update.message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏–∏ —Å—á—ë—Ç–∞:\n{response.text}",
                reply_markup=main_menu()
            )

        context.user_data.clear()

    elif action == "check_status":
        account_display = update.message.text.strip()
        if "-" in account_display:
            account_no = account_display.split("-")[-1].strip()
        else:
            account_no = account_display.strip()

        data = get_invoice_list(EXPRESS_PAY_TOKEN, account_no)

        if "Error" in data:
            await update.message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞ –æ—Ç ExpressPay:\n{data['Error']['Msg']}",
                reply_markup=main_menu()
            )
            return

        items = data.get("Items", [])
        if not items:
            await update.message.reply_text(
                f"‚ùå –°—á—ë—Ç `{account_display}` –Ω–µ –Ω–∞–π–¥–µ–Ω.",
                parse_mode="Markdown",
                reply_markup=main_menu()
            )
            return

        invoice = items[-1]
        status = int(invoice.get("Status", 0))
        amount = invoice.get("Amount", "‚Äî")
        created_raw = invoice.get("Created", "")
        date = (
            datetime.strptime(created_raw, "%Y%m%d%H%M%S").strftime("%d.%m.%Y %H:%M")
            if created_raw else "‚Äî"
        )

        statuses = {
            1: "–û–∂–∏–¥–∞–µ—Ç –æ–ø–ª–∞—Ç—É",
            2: "–ü—Ä–æ—Å—Ä–æ—á–µ–Ω",
            3: "–û–ø–ª–∞—á–µ–Ω",
            4: "–û–ø–ª–∞—á–µ–Ω —á–∞—Å—Ç–∏—á–Ω–æ",
            5: "–û—Ç–º–µ–Ω–µ–Ω",
            6: "–û–ø–ª–∞—á–µ–Ω –∫–∞—Ä—Ç–æ–π",
            7: "–ü–ª–∞—Ç—ë–∂ –≤–æ–∑–≤—Ä–∞—â–µ–Ω"
        }

        await update.message.reply_text(
            f"üìä *–°—Ç–∞—Ç—É—Å —Å—á—ë—Ç–∞*\n\n"
            f"–ù–æ–º–µ—Ä: `{account_display}`\n"
            f"–°—Ç–∞—Ç—É—Å: *{statuses.get(status, '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}*\n"
            f"–°—É–º–º–∞: {amount} BYN\n"
            f"–î–∞—Ç–∞ –≤—ã—Å—Ç–∞–≤–ª–µ–Ω–∏—è: {date}",
            parse_mode="Markdown",
            reply_markup=main_menu()
        )

        context.user_data.clear()

    else:
        await update.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu())


# === –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–∏—Ñ—Ä–æ–≤–æ–π –ø–æ–¥–ø–∏—Å–∏ ===
def verify_signature(data: str, received_signature: str, secret_word: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–¥–ª–∏–Ω–Ω–æ—Å—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ—Ç ExpressPay."""
    if not secret_word:
        return True  # –µ—Å–ª–∏ –Ω–µ –∑–∞–¥–∞–Ω —Å–µ–∫—Ä–µ—Ç, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É

    digest = hmac.new(
        secret_word.encode("utf-8"),
        msg=data.encode("utf-8"),
        digestmod=hashlib.sha1
    ).hexdigest().upper()

    return digest == received_signature.upper()


# === –ü—Ä–∏—ë–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π ExpressPay ===
async def handle_payment_notification(request: web.Request):
    try:
        post_data = await request.post()
        payload = post_data.get("Data")
        signature = post_data.get("Signature")

        if not payload:
            return web.Response(status=400, text="Missing Data")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–ø–∏—Å—å
        if not verify_signature(payload, signature or "", EXPRESS_PAY_SECRET_WORD):
            print("‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –ø–æ–¥–ø–∏—Å—å ExpressPay!")
            return web.Response(status=403, text="Invalid signature")

        payment_info = json.loads(payload)

        msg = (
            f"üí∏ *–ü–æ—Å—Ç—É–ø–∏–ª –ø–ª–∞—Ç—ë–∂!*\n\n"
            f"–ù–æ–º–µ—Ä —Å—á—ë—Ç–∞: `{payment_info.get('AccountNumber', '‚Äî')}`\n"
            f"–°—É–º–º–∞: {payment_info.get('Amount', '‚Äî')} BYN\n"
            f"–î–∞—Ç–∞: {payment_info.get('DateResultUtc', '‚Äî')}"
        )

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∞–¥–º–∏–Ω—É
        if ADMIN_CHAT_ID:
            app = request.app["bot_app"]
            await app.bot.send_message(chat_id=ADMIN_CHAT_ID, text=msg, parse_mode="Markdown")

        return web.Response(status=200, text="OK")

    except Exception as e:
        print("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è:", e)
        return web.Response(status=500, text="Internal Error")


# === –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ===
def main():
    app = Application.builder().token(BOT_TOKEN).build()

    # Telegram handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CallbackQueryHandler(button))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    # Webhook —Å–µ—Ä–≤–µ—Ä
    async def on_startup(app_):
        app_["bot_app"] = app

    web_app = web.Application()
    web_app.add_routes([
        web.post("/payment_notification", handle_payment_notification)
    ])
    web_app.on_startup.append(on_startup)

    port = int(os.environ.get("PORT", 8443))
    app.run_webhook(
        listen="0.0.0.0",
        port=port,
        url_path=BOT_TOKEN,
        webhook_url=f"{APP_URL}/{BOT_TOKEN}",
        web_app=web_app
    )


if __name__ == "__main__":
    main()
